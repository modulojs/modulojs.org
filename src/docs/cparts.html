<!DOCTYPE HTML><script Modulo src="/static/js/Modulo.js" -src="/static/components/cms/"></script><cms-MarkdownPage><script type=md>---
title: CParts
---

# CParts


> **Custom CParts?** Here we describe core CParts used by component developers,
> which are sufficient for most common use-cases. However, if you are instead
> looking to extend this core functionality with custom CParts written in
> JavaScript, refer to the [Custom Component Part examples on the demos
> page](/static/demos/editor.html?file=/static/demos/advanced/custom_cpart_for_api.html),
> at least until more thorough CPart API
> documentation is developed.

The central concept to Modulo Components is that of _Component Parts_. Because
it is so central, saying _Component Parts_ over and over gets tiresome, so in
this documentation it will be typically shortened to _CParts_. Every component
definition consists of configuring one or more CPart definitions. Modulo comes
"batteries-included" with about 8 CParts, which provide the core functionality
of building Modulo Components, and are documented here.

Conventionally, when defining components, CParts are listed in the following
order within a given _Component_ definition:

1.  Props
2.  Template
3.  _(Any other CParts)_
4.  State
5.  StaticData
6.  Script
7.  Style

The rationale for this ordering is to put _Props_ and _Template_ first since
they are often the first CParts that are important to read when trying to
understand or debug the behavior of a _Component_, while putting _Style_ last
as it's typically the least important to read. Note that ordering makes a
difference: They will be processed in the order given.

Typically, you will not need to have more than one of the same type of CPart in
a given component. However, in some cases for particular CParts it might make
sense, such as to mix in multiple _Styles_ into a single _Component_. In the
case of duplicate CParts of the same type, often the behavior is that "whoever
gets the last word in wins", or the configuration specified by the final CPart
takes precedence (although this depends on the CPart in question).

# Props

> **Read-only** Props are read-only within a component, and only be set by the
> parent component. If the values change, the component re-renders with the new
> values. They are only supposed to be information being _passed to_ the
> component, which means they can't be changed internally. For internal,
> mutable data, use [State](#state) instead.

Props allow components to receive data. You can think of Props as being like
"function parameters": They allow you to pass down "arguments" (attributes) to
component which can then modify it's appearance, behavior, or content based on
the values of these parameters.

Props are set by the parent component (or HTML page). For String values, use plain attributes (e.g. `<x-Btn design="round">`). For any non-String types, you can use _data props_ set using a `:=` directive syntax for (e.g. `<x-Chart data:='[1, 2, 3]'>`).

### renderObj

Props contributes it's received values to the renderObj. Examples:

1.  Prop set like: `<x-Btn design="round">` will be accessible on the renderObj like `renderObj.props.design`, and in the Script or Template CParts like `props.design`.
2.  Prop set like: `<x-Chart data:='["a", "b"]'>` will be accessible on the renderObj like `renderObj.props.data` (with individual items accessed with code that ends with "`.data[0]`"), and in the Script or Template CParts like `props.data`.

# Script

> **Custom vs Script CPart** \- The general rule of thumb is that _Script_ tags are for custom, component-specific behavior, or to fill in gaps in stitching together other CParts, while writing Custom CParts is for interfacing with async, APIs, or any time that a Script CPart gets too cumbersome. Modulo's philosophy is to allow separation of work between _component development_ (HTML, CSS, templating, and high-level behavior), and _CPart development_ (complex JavaScript and APIs).

_Script_ CParts allow you to define custom behavior for components using the full power of JavaScript. The most common use of _Script_ tags is to add more sophisticated interactive behavior. Instead of just relying on premade CParts, with a Script tag you can program any custom behavior into your component.

### Definition

_Script_ is traditionally included in _Component_ definitions below the _State_ or _Template_ tag. _Script_ has no expected attributes, but instead only has a text-content.

#### Typical use

The most common use of a _Script_ CPart is to specify custom JS code that is either run once after fulling loading all dependencies, or once each time the component renders. See below for a simple example:


```
<Component name="ButtonExample">
    <Template>...</Template>
    <State>...</State>
    <Script>
        console.log("Will execute once after loading dependencies");
        function initializedCallback() {
            console.log("Executes every time an instance of ButtonExample is created");
        }
        function updateCallback() {
            console.log("Executes after every rerender of the component");
        }
    /Script>
</Component>
```

#### Using within embedded component definitions

Problems arise when attempting to include a _Script_ CPart within an embedded
Component `<script Modulo>` definition, e.g. one that is being defined within
the script tag of the same HTML file that it is being used on. This is because
the `<` `/Script>` tag will end up closing off the outer `<script>` tag early,
due to HTML syntax. The reason is that `</` `script>` is a special syntax that
automatically closes the outer tag, and also HTML cannot distinguish capital
(the `<Script>` CPart) vs lowercase (the outer `<script>` tag). The ideal
solution is to simply move the component to a separate library file, included
with `-src=` syntax, since that is preferred in general, and solves other
issues as well (e.g. templating instructions in HTML tags).  However, if you
simply must include a _Script_ tag in an embedded component definition you can
write `<def Script>` as the opening tag, and `</def>` as the closing tag. See
the following:


```
<script Modulo src="https://unpkg.com/mdu.js">
    <Component name="ButtonExample">
        <def Script>
            console.log("Hello, world!");
        </def>
    </Component>
/script>
```

A better alternative is to use the slightly more verbose `<template Modulo>` instead:

```
<template Modulo>
    <Component name="ButtonExample">
        <Script>
            console.log("Hello, world!");
        /Script>
    </Component>
</template>
<script src="https://unpkg.com/mdu.js">/script>
```

### Defining event callbacks

The most common purpose of a Script CPart is to add custom behavior when certain "events" occur to your component. Consider the following example of 3 click events:

```modulo_demo
<Template>
    <button @click:=script.doConsole>Console Log</button>
    <button @click:=script.doAlert>Show Alert</button>
    <button @click:=script.countUp>Counter {{ state.num }}</button>
</Template>
<State
    num:=42
></State>
<Script>
    function doConsole() {
        console.log("Event callback. State.num is:", state.num);
    }
    function doAlert() {
        alert("Event callback. State.num is: " + state.num);
    }
    function countUp() {
        state.num++;
    }
/Script>
```

In this, the _Script_ CPart defines a function named `countUp`. The `@click:=`
attribute on the button utilizes directives to attach a "click event" to the
button, such that when a user clicks on that button it will invoke the
`countUp` function.

From within event callbacks, the _Script_ CPart exposes the current renderObj as variables. So, `state` by itself is equivalent to `renderObj.state`. This enables us to directly modify the state by simply doing `state.count++`. By default, components rerender after every event, so after the event the component will rerender and visually reflect the state changes.

This means that all renderObj variables will be available here, in a similar way to how _Template_ exposes them: For example, you can use code like `props.XYZ` to access data from a _Props_ CPart.

You can also access the JavaScript Object instances of the CPart Class. To access those, you use the `cparts`

Finally, the variable `element` will refer to the HTML element of the current component. This is useful for direct DOM manipulation or interfacing with other frameworks or "vanilla" JavaScript. Generally, however, you should avoid direct DOM manipulation whenever you can, instead using a _Template_ CPart to render the component (otherwise, the _Template_ will override whatever direct manipulation you do!).


> **Template vs renderCallback**
> Before replacing a _Template_ with a `renderCallback`, first consider using
> prepareCallback or extending the templating language with a custom filter.
> The _Templating_ language is intentionally limited and result in more
> readable code and a cleaner separation of concerns of logic (JavaScript) from
> presentation (HTML templates).

### Defining lifecycle callbacks

By naming functions with certain names, you can "hook into" the component
rendering lifecycle with callbacks.

You can define a function with any of the following names and expect it to be
invoked during it's namesake lifecycle phase: `initializedCallback`,
`prepareCallback`, `renderCallback`, `reconcileCallback`, and finally
`updateCallback`.

See below for an example of defining a custom `prepareCallback` in order to
"hook into" the component rendering lifecycle to execute custom code. The
return value of this function is available to the _Template_ CPart when it
renders during the `render` lifecycle.


```modulo_demo
<Template>
    {% for item in script.data %}<p>{{ item }}</p>{% endfor %}
    <p>(C) {{ script.year }} All Rights Reserved</p>
</Template>
<Script>
    function prepareCallback() {
        return {
            data: ["a", "b", "c"],
            year: (new Date()).getFullYear(),
        };
    }
/Script>
```

> **Template literals?** Modern JavaScript has a built-in mini-templating
> system. Learn more at
> [MDN's Template literals
> reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).

For fine-grained control over a component's rendered HTML, you can hook into
the renderCallback.  While not recommended for most usage, it remains an option
to use the renderCallback to write JS that constructs the HTML in a custom
fashion, such as using a third party templating system, or simply using
template literals.

Another option is to use this to, for example, use backtick template literals
for templating, if for whatever reason Modulo's templating language is
insufficient. See below:


```modulo_demo
<State
    name="Ha-Joon Chang"
    books:='[ "Edible Economics", "Kicking Away the Ladder" ]'
></State>
<Script>
   function renderCallback() {
        component.innerHTML = `
            <p>Author: ${ state.name }</p>
            <ol>${
                state.books.map(title => `
                    <li>${ title }</li>
                `).join('')
            }</ol>
        `;
    }
/Script>
```


### Defining directive callbacks

You can also create "custom directives" from within the Script tag. Read more
about this in the section on [Directives](/docs/directives.html)

### Execution context

#### Static execution context (default)

By default, the `factory` phase is when the code in the script tag itself gets executed. That is, it is executed exactly once while the component class is being prepared, before anything is yet even mounted on the document. This means that that any loose variables defined will be "static", or shared between all instances of that component.

**Static execution _Script_ tags will only correctly isolate synchronous
code.** It is thus recommended to keep your _Script_ tag to only contain
synchronous code, that is, no async callbacks. This is an intentional
limitation, as _Script_ tags are intended for _synchronously_ patching together
behavior around potentially _asynchronous_ CParts. There is also a potential
for a bug: If there are multiple instances of the same component on the same
page, with async callbacks ready at the same time, it can cause the wrong
state, props or other variables or CParts to get mixed up and go to the wrong
component. Asynchronous coding should be thus moved to a custom CPart, that is
then used in the script tag in a declarative, synchronous manner. The CPart API
gives you low-level access, and makes no assumptions about using a synchronous
or asynchronous coding style.

That said, Modulo is intended to be useful as a glue language and it's common
to find asynchronous snippets that you might want to quickly integrate into an
existing component. Read on for a few ways to bend this rule in order to better
integrate third party code.

#### Lifecycle execution context

> **ALPHA API NOTE:** This feature might be renamed in a future release of
> Modulo alpha:
> [See Issue #26](https://github.com/modulojs/modulo/issues/26)

##### Per component: `lifecycle="initialized"`

Setting `lifecycle="initialized"` behaves very similarly to the "static"
execution context (the default): For both, functions defined there will be
available to be attached to events, and you can define Callback and Mount and
Unmount functions. However, there is one important difference: It will execute
_each and every time_ an instance of the component first mounts on the page.
That is, it will run everything in that script tag once per component use. This
keeps all the data in the script tag private to that component, allowing for
asynchronous code.

It also allows use of the private variables as a sort of state. That is not
recommended usage, but might be useful for integrating with other JavaScript
state or store management systems.

### renderObj

The Script CPart "exports" a variety of properties to the `renderObj`, all of which should be considered "read-only".

* `script.someFunctionName` for functions declared like
  `function someFunctionName` \- In addition to "exports", the script tag will
  also make available all functions that you have declared using the
  "old-school" named-function style syntax. This is what allows attaching
  events to be so simple: Simply define a named-function in your script tag
  (e.g.  `function doStuff(payload, ev) { ...`), and then it can be referenced
  elsewhere (e.g. in the template with: `@click:=script.doStuff` template with
  a click event like: It will ignore any "arrow functions" (`() => {}`), or any
  other anonymous functions (e.g. functions declared like
  `const myFunc = function () { ...` will also be ignored). That's not to say
  you can't declare your functions like this: However, you should only do so if
  you do not want them to be automatically exported.
* `script.exports` \- This gives you fine-grained control, allowing you to
  export arbitrary static variables, functions, or data. This is useful for
  building up static data structures to be shared between all instances of this
  component, which can then be accessed in the template. This _should not_ be
  used as a store or state variable (use the _Store_ CPart for that). Also, it
  should not be used for simply storing static data that requires no further
  code or manipulation (use the _StaticData_ CPart for this). For example:

```
<Template>
    <p>{% for item in script.exports.bigArray %}
        {{ item }},
    {% endfor %}</p>
</Template>
<Script>
    script.exports.bigArray =
        Array.from({ length: 100 })
        .map((val, i) => `i liek ${i} turtles`);
/Script>
```

# State

The _State_ is for component instances to store changing data. This could include anything from text a user entered into a form, data received from an API, or data that represents UI flow changes, such as the visibility of a modal. For more discussion of State, see [Tutorial Part 3](/docs/tutorial_part3.html#state).

By default (that is, with no `-store` attribute), state data is unique to every component instance, and components can never directly access sibling or parent data. It is possible to indirectly reference it, however, by passing state data from a "parent" component to a "child" components within the parent by passing it via a _Props_ attribute. In this case, the data should be considered read-only to the child component, like any other _Props_ data.

### Definition

State is traditionally included in Component definitions below the _Template_ tag, but above the _Script_ tag. This makes sense because functions in the _Script_ tag typically manipulate state in order to render new HTML in the _Template_, making _Script_ a sort of mutable bridge between _Script_ and _Template_. State is defined in a similar way to Props: Only defined with properties, but no contents.

See below for an example of defining a _State_ CPart:


#### Example 1

Two State variables specified, of type String and Number:

```
<State
    name="Luiz"
    favenum:=13
></State>
```

#### Example 2

Many State variables of different types:

```
<State
    color="blue"      (String)
    count:=1          (Number)
    loading:=false    (Boolean)
    speed:=null       (null value)
    items:=&apos;[    (JSON Array)
        "abc",
        "def"
    ]&apos;
    obj:=&apos;{      (JSON Object)
        "a": "b",
        "c": "d"
    }&apos;
></State>
```

#### Example 3

Building up complicated JSON data with "." syntax:

```
<State
    user:={}
    user.name:=&apos;"gigasquid"&apos;
    user.uid:=1313
    user.address:={}
    user.address.billable:=null
    user.address.ready:=true
></State>
```


Note that all "state variables" _must_ have an initial value. It's okay to make
the initial value be `null` (as in the "speed" example above), or other some
placeholder that will later be replaced.



### Linking State globally with stores

If you want to share data between components globally, such that any component
can modify the data causing a re-render to all linked components, such as user
log-in information or global state data, then you can use the powerful `-store`
attribute:

```
<State
    -store="userinfo"
    username="pombo"
    tags:=&apos;["admin", "printing"]&apos;
></State>
```

With this, any state with the given store _throughout your application_ will
share state and subscriptions to updates.

#### Limiting a store with -only

Sometimes, you'll only want to subscribe to certain attributes parts of a store:

```
<State
    -store="userinfo"
    -only:='["username"]'
    username="pombo"
></State>
```

For a full example of `-store` in use, [see the Global Store
demo](/static/demos/editor.html?file=/static/demos/advanced/global_store.html).

### CPart properties

The actual data in a _State_ CPart is stored on it's "data" property. This
property is a regular JavaScript Object, and thus can store any JavaScript data
type. As an example, in a _Script_ CPart, you can directly reference this
property with the code `cparts.state.data`.

When writing the _State_ CPart definition, you must declare or pre-define each
"state variable" or property of the "data" Object that you want to use. It is
not permitted to create new state variables later on. In other words, if you
only define `cparts.state.data` as having `.count` and `.title` as "state
variables" (aka properties of the "data" Object), then an attempt like
`cparts.state.data.newstuff = 10;` may result in an error. If you are dealing
with a situation where you have an unknown quantity of data, such as from an
API, the correct approach is to store it all within a nested Object _inside_
the state data Object, e.g. such as an `data.apiResults` Object or Array.
Unlike top-level "state variables", it's okay to add properties, modify, or
build upon nested Objects.

While it's allowed to assign any arbitrary reference as a _State_ variable,
including complex, unserializable types such as function callbacks, it's highly
recommended to try to keep it to primitive and serializable types as much as
possible (e.g. String, Number, Boolean, Array, Object). The reason being that
there may be future features or third-party add-ons for _State_ which will only
support primitive types (as an example, that would be required to save state to
localStorage). If you want to store functions, consider using a
`prepareCallback` to generate the functions within a Script context, and only
store the data needed to "generate" the function in the state (as opposed to
storing a direct reference to the function itself).

### renderObj

State contributes it's current data values to the renderObj. Examples:

* State initialized like: `<State name="Luiz">` will be accessible on the
  renderObj like `renderObj.state.name`, and in the Script or Template CParts
  like `state.name`.
* State initialized like: `<State stuff:='["a", "b"]'>` will be accessible on
  the renderObj like `renderObj.state.info` (with individual items accessed
  with code that ends with "`.stuff[0]`"), and in the Script or Template CParts
  like `state.info`.

### Directives

State provides a single directive:

* `[state.bind]` \- Two-way binding with State data, with the key determined by
  the `name=` property of whatever it is attached to. You can attach a
  `[state.bind]` directive to any HTML `<input>`, and the _State_ CPart's
  two-way binding will cause the input value to be updated if the state
  variable ever changes, and if a user edits the input triggering a `"keyup"`
  or `"change"` event, the state variable will be updated (along with,
  typically, a re-render of the component).


```
<Template>
<div>
    <label>Username:
        <input [state.bind] name="username" /></label>
    <label>Color ("green" or "blue"):
        <input [state.bind] name="color" /></label>
    <label>Opacity: <input [state.bind]
        name="opacity"
        type="number" min="0" max="1" step="0.1" /></label>

    <h5 style="
            opacity: {{ state.opacity }};
            color: {{ state.color|allow:'green,blue'|default:'red' }};
        ">
        {{ state.username|lower }}
    </h5>
</div>

</Template>

<State
    opacity="0.5"
    color="blue"
    username="Testing_Username"
></State>
```

# StaticData

The _StaticData_ CPart is useful for loading JSON files to use as a data
source. StaticData has no "refresh" capability, meaning this should only
consist data that you do not expect to change while running your program, such
as type definitions or data from a API that does not change frequently.

### Usage

The StaticData CPart can be used in two different ways. The most common is
loading data from a JSON file or JSON API by specifying a `-src=` attribute.
During development, this will "fetch" when refreshing the page, but once you
"build" the component, the specified content will be "frozen in time" during
the build, and bundled in with the resulting JS file with any filtering
applied.

The other usage is to simply "hardcode" the data in JSON syntax within the
element itself. There is no functional difference of including data in JSON
syntax in a StaticData CPart to simply adding a Script CPart that uses
`script.exports` to expose data, other than it being slightly more convenience
(e.g. less typing), and intentionally less flexible compared to a script CPart.

### attrs

* `-src` \- Just like any other CParts, the `-src=` attribute lets you load the
  content from another URL. This could be from an API (e.g. something like
  `-src="https://some.api.com/v1/getdata?p=3"`), or for loading from a file
  (e.g. `-src="./data/weatherData.json"`), or for loading from a file. If not
  specified, then the data must be specified within the StaticData tag, or else
  it will be simply "undefined".
* `-data-type` \- This optional attribute should be set to a file-type string
  (e.g. extension) of a registered converter. By default, the ones that are
  available are:
    * *Default:* `-data-type="json"` - This is a strictly JSON syntax (no
      trailing commas, double quotes only)
    * `-data-type="js"` - This is a JavaScript syntax JSON object (allows for
      trailing commas, optional quotes, and even invoking functions to
      manipulate the data before "freezing" it or bundling it)
    * `-data-type="csv"` - This is a simple CSV parser, great for importing
      spreadsheet data as exported from popular spreadsheet apps
    * `-data-type="txt"` - This is a plain text file. It will be made available
      as a string in the renderObj.


### renderObj

The StaticData CPart exposes it's data directly (e.g. so it can be accessed in Script, Template, etc).

### Usage Examples

Examine the following examples for ideas on how to use StaticData:


#### Using an API
```modulo_demo
<!-- Load package.json file directly from GitHub -->
<Template>
    {{ staticdata.name }} v{{ staticdata.version }}
    (by {{ staticdata.author }})
</Template>
<StaticData
    -src="https://raw.githubusercontent.com/modulojs/modulo/main/package.json"
></StaticData>
```

#### Displaying a table with a for loop

```modulo_demo
<Template>
    <h4>uid</h4> <h4>Title</h4> <h4>Body</h4>
    {% for item in staticdata %}
        <div>#{{ item.userId }}</div>
        <div>{{ item.title|truncate:5 }}</div>
        <div>{{ item.body|truncate:10 }}</div>
    {% endfor %}
</Template>
<!-- Load 100 items of sample data from a
     JSON placeholder website "typicode" -->
<StaticData
    -src="https://jsonplaceholder.typicode.com/posts"
></StaticData>
<Style>
    :host {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        height: 150px;
        overflow: auto;
    }
</Style>
```

#### Filtering with -data-type="js"

```modulo_demo
<Template>
    <h4>uid</h4> <h4>Title</h4> <h4>Body</h4>
    {% for item in staticdata %}
        <div>#{{ item.userId }}</div>
        <div>{{ item.title|truncate:5 }}</div>
        <div>{{ item.body|truncate:10 }}</div>
    {% endfor %}
</Template>
<!-- Load items from a JSON placeholder website "typicode", and then use the
contet of a "js" StaticData tag to pre-filter them right after loading -->
<script StaticData -data-type="js" -src="https://jsonplaceholder.typicode.com/posts">
    .filter(post =>
        post.userId === 5
    )
/script>

<Style>
    :host {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        height: 150px;
        overflow: auto;
    }
</Style>
```


#### Embedding data with -data-type="js"

```modulo_demo
<Template>
    {% for item in staticdata %}
        <label>
          <img src="{{ item.thumbnailUrl }}" />
          <tt>#{{ item.id }}</tt>
          {{ item.title|capfirst }}
        </label>
    {% endfor %}
</Template>
<!-- Hardcode lorem ipsum / sample data, with a custom data type specified so
we can use the more relaxed JavaScript syntax rules -->
<script StaticData -data-type="js">
[
  {
    id: 1,
    title: "accusamus beatae ad facilis cum similique qui sunt",
    url: "https://via.placeholder.com/600/92c952",
    thumbnailUrl: "https://via.placeholder.com/50/92c952"
  },
  {
    id: 2,
    title: "reprehenderit est deserunt velit ipsam",
    url: "https://via.placeholder.com/600/771796",
    thumbnailUrl: "https://via.placeholder.com/50/771796"
  },
]
/script>
<Style>
    :host {
        display: flex;
        height: 150px;
        overflow: auto;
    }
    tt {
        font-size: 2rem;
    }
</Style>
```

  
# Style

The _Style_ CPart allows us to write CSS for our component. This allows us to group styles within our component, and keep them isolated from other components, without having to come up with long, confusing class names every time. CSS written here will be automatically prefixed so that it will only apply to your component and/or any HTML that it generates, such as by the _Template_ CPart.

### Usage

In general, you can freely write any number of CSS rules for your components. They will be prefixed based on a few regular expression replacement steps, such that they only apply to the elements within your component. For example, a rule like `a { color: blue }` in a component named `name="HelloBtn"` that has been imported with `namespace="mylib"` would result in the following, fully-prefixed rule: `mylib-HelloBtn a { color: blue }`

### Isolation modes

The Style CPart is capable of "isolating" it's contents using one of several strategies: Prefix isolation (using the "descendent" CSS selector), Class isolation (where a class is attached to all matching elements generated by the Component, and the `:is()` CSS selector is used to join the class with all selectors in the Component), and finally Shadow

#### Prefix isolation (default for `<Component ...`)

By default, components have "regular" rendering mode. This will cause it to prefix like described above. That is, every selector in the CSS styles enclosed will be prefixed with the name of the component.

For example, a rule like `div.alert { color: green }` in a component named `name="HelloBtn"` that has been imported with `namespace="mylib"` would result in the following, fully-prefixed rule: `mylib-HelloBtn a { color: blue }`

#### Class isolation (`<Component mode="vanish"...`)

By default, components have "regular" rendering mode. If you've configured your component to instead use "vanish" rendering or "vanish-into-document", it will to make the component function as basically a one-time template that "vanishes" away after rendering, leaving only it's children. When this mode is set, the Style CPart will enable class-based isolation.

The technique for this is the most involved of the three isolation modes: It will modify your resulting DOM to add a class, by default generated from the Component name, to every referenced element. Finally, it will change the style sheet to only select elements that have this new class.

Example: If there is a style like `p.quote strong`, in a component named `mylib-HelloBtn`, then it will re-use the component name as a CSS class to the which it adds to the `strong` element specified. Then it will use the `:is()` CSS selector is used to join the class, resulting in the CSS of: `.mylib-HelloBtn:is(p.quote strong)`

#### Shadow DOM isolation (`<Component mode="shadow"...`)

By default, components have "regular" rendering mode. If you've configured your component to instead use "Shadow DOM" rendering to protect it from getting outside CSS applied to it, then the _Style_ will be "encapsulated" or inserted in the "shadow root" of component instances, as opposed to the document root. (More on this here: [MDN's "ShadowRoot.styleSheets"](https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot/styleSheets))

When using Shadow DOM, both the stylesheet and DOM will NOT be modified. Instead, the CSS will automatically be isolated by nature of the browser's shadow DOM CSS isolation feature. This isolates the component's DOM from the parent's styles, causing guaranteed CSS isolation. Keep in mind, however, it creates a new "open shadow root" DOM node, and prevents global styles (e.g. regular link tags) from being applied. If you prefer using shadow DOM for components, you can share base-style across shared Style components (browsers should notice repeated duplicate shadow DOM sheet insertions and should be optimized accordingly).

`div.alert { color: green }` in a component named `name="HelloBtn"` that has been imported with `namespace="mylib"` would result in the following, fully-prefixed rule: `mylib-HelloBtn a { color: blue }`

`isolate-class` \- Force "isolate class" feature to be on, even if the component is not in a vanish-based rendering mode. component itself. This will work for both "regular" and "shadow" rendering mode. For example, in regular rendering mode, if you have the CSS `:host { color: red }` in a component named `name="MyChart"` that has been imported with `namespace="mylib"`, then it would create the following, fully-prefixed CSS rule: `mylib-MyChart { color: red }` `:host` \- Use the ":host" pseudo-element to select the component itself. This will work for both "regular" and "shadow" rendering mode. For example, in regular rendering mode, if you have the CSS `:host { color: red }` in a component named `name="MyChart"` that has been imported with `namespace="mylib"`, then it would create the following, fully-prefixed CSS rule: `mylib-MyChart { color: red }`

### Usage Example

```modulo_demo
<Template>
Hello <strong>Modulo</strong> World!
<p class="neat">Any HTML can be here!</p>
</Template>
<Style>
/* ...and any CSS here! */
strong {
    color: blue;
}
.neat {
    font-variant: small-caps;
}
:host { /* styles the entire component */
    display: inline-block;
    background-color: cornsilk;
    padding: 5px;
    box-shadow: 10px 10px 0 0 turquoise;
}
</Style>
```

# Template

The _Template_ CPart allow components to render their HTML content using a
tiny domain-specific language, called the _Modulo Templating Language_.

Without a _Template_ CPart (or equivalent custom code), the default behavior of
the _Component_ CPart is to make no attempt to alter their contents. However,
most components require complicated HTML structures within them. This is where
Templates come into play: They generate the `innerHTML` of a component.

Templates are not DOM-based, but instead render synchronously to a String
during the `render` [lifecycle phase](/docs/lifecycle.html), and
store the results in `renderObj.component.innerHTML`. The _Component_ CPart
will read this HTML code during the `reconcile` phase and then "reconcile",
modify it's contents to resemble the target innerHTML. (More on this is in [the
Component CPart documentation above](#component).)

Every time a Component renders, the Template will render using the _renderObj_
as a "template context", or, in other words, using the various CPart's
contributions to the _renderObj_ as Template variables that can be inserted
into the HTML.

## Templating reference

[See the Templating documentation for further information on the functionality
of the Templating CPart.](/docs/templating.html)


## Usage example


```modulo_demo
<Template>
<p>There are <em>{{ state.count }}
  {{ state.count|pluralize:"articles,article" }}</em>.</p>

{# Show the articles #}
{% for article in state.articles %}
    <h4 style="color: blue">{{ article.headline|upper }}</h4>
    {% if article.tease %}
      <p>{{ article.tease|truncate:30 }}</p>
    {% endif %}
{% endfor %}
</Template>

<!-- The data below was used to render the template above -->
<State
    count:=42
    articles:='[
      {"headline": "Modulo released!",
       "tease": "The most exciting news of the century."},
      {"headline": "Can JS be fun again?"},
      {"headline": "MTL considered harmful",
       "tease": "Why constructing JS is risky business."}
    ]'
></State>
```


