<!DOCTYPE HTML><script Modulo src="/static/js/Modulo.js" -src="/static/components/cms/"></script><cms-MarkdownPage><script type=md>---
tutorial: Part 3
---


In Part 3 of this tutorial, we'll start exploring code that permits individual
components to store, modify, and link together data, allowing for complex
behaviors. 

We'll learn how to use Template Tags, to optionally include, or duplicate parts
of our HTML templates for data or properties.  We'll learn how to use
StaticData, that lets us import JSON or CSV file types, or APIs that use these
types, into our Modulo components, so that we can use template tags to explore
3rd party data.

Before we get to these more powerful features of Modulo, we'll need to first
explore Data Props, and how they enable different JavaScript data types.

# Data Props

> **Other Directives** - All directives are "provided" by a CPart. That is,
> including CParts in your component definition may "enable" more directives in
> your HTML. Data-prop (`[component.dataProp]` or `:=`), for example, is a
> built-in feature of the _Component_, which means it's always available.
> Directives are not the main focus of this tutorial.  To learn more, including
> how to author your own directives using JavaScript, [see
> _Directives_](/docs/directives.html). However, for the purpose of this
> tutorial we will have no need to use directives outside of the built-in
> directives that come with Modulo.

Before we go any deeper into Template Tags or _StaticData_, we need to explore
"data props", and before that, we need to review _directives_. The term
_directives_ in Modulo refers to special attributes that you add to HTML to add
extra functionality.. You can recognize a _directive_ by spotting certain
special characters in the attribute name. We've seen one in the previous
tutorial section, `[state.bind]`. For example, `<input [state.bind] />` is an
`input` HTML tag with a `[state.bind]` directive. Some directives will have a
square-bracket syntax (e.g. `[ ]`), while others might use other special
characters to set them apart from "normal" attributes (e.g.  `:=` syntax we'll
learn next). While re-rendering, Modulo scans the resulting DOM to set-up or
"mount" any directives it encounters.

Directives are useful for a variety of tasks, ranging connecting CParts to each
other, to more complicated modifications to DOM elements.  ).

## The dataProp directive `:=`

We'll learn one more directive next: _data prop_  or `:=` syntax

> **Why don't we use "strings" for numbers?** Using strings of digits (i.e. in
> quotes) instead of the numbers themselves means that things like arithmetic
> won't work as intended. Example: If state variable `count="1"`, then
> `state.count + 10` will result in `"110"` instead of the desired `11`, since
> it's a string of digits, so `"1" + "10" = "110"`

Typically, when we add attributes to anything, whether it is a CPart or even
just in regular HTML, the attribute value can only be a string. This means when
we did `<State count="1" ... >` previously, we made a mistake: The `count`
variable didn't get assigned to `1` the _Number_, but rather `"1"` the
_String_. To fix it, we do the following:

    <State
        count:=1
        color="blue"
    >&lt;/State&gt;

This is called a _data prop_ directive. You can identify a _data prop_
directive (`:=`), by spotting an attribute name that is suffixed with a colon
right before the equal sign, like this: `attributeName:=value`.


### Final notes on Data Props

-  Keep in mind that _data props_ directives are not the same as the _Props_
   CPart. They are, however, related, in that the _Props_ CPart looks for both
   regular attributes and data props: You can in fact set any _Props_
   attributes with the `:=` syntax, for data other than Strings.
-  _Data props_ support any JSON literal type. Technically, _data props_ values
   can have double quotes just like normal String-based attributes.  However,
   as a stylistic convention, you may omit the double quotes for any one-word
   value, and should use only single quotes for complex types, such as
   JSON-formatted Arrays or Objects. See below for stylistic examples of data
   props with different types:



# Template Tags

> **Built-in Template Tags and Custom Template Tags** - Modulo comes with many
> template-tags pre-installed: Read [Templating Reference - Built-In
> Tags](/docs/templating-reference.html#builtintags) for examples of all
> template-tags available.  This includes the "if" template-tag, which allows
> for conditional rendering (e.g.  "only show the submit button if a form is
> filled correctly"), and the "for" template-tag, which allows for HTML to be
> repeated for each item of some given data (e.g. "every blog post get's it's
> own `<li>` element").  Utilizing JavaScript, you can also define custom tags,
> although it is more challenging than with filters.


## Intro to Template Tags

In addition to filters, the Modulo templating language also support powerful
"template tags", which allow for more complicated custom behavior.  Unlike
template variables or filters, they use `{%` and `%}` (instead of `{{` and
`}}`) to designate where they are in the _Template_ code.

### Syntax

Template tags are in the format of `{% tag %}`. 
They allow for more complicated transformations to the HTML code generated.
For example, here are a few:

    {% include other_template %}

    {% comment %}
        ...
    {% endcomment %}

    {% if state.expanded %}
        ...
    {% endif %}



## The if-tag

One of the most useful template tags you will use is the if tag, written like
this: `{% if %}`.  The if-tag allows for conditional rendering of HTML code
based on the condition supplied.

See below for two examples of using the "if" tag:

    <h1>{{ props.title }}</h1>
    {% if state.expanded %}
        <div><p>Details: {{ props.details }}</p></div>
    {% endif %}
    <hr />
    {% if props.link %}
        <a href="{{ props.link }}">Read more...</a>
    {% endif %}



##### Try It Now

1. Examine the code below. Do you understand how the `if` template-tag checks
the value of `state.word`  to see if it is filled in, and only shows it back to
the user when the user has started typing?

```modulo_demo
<Template>
    <div>
        <label>Enter a word to see it reversed:
            <input [state.bind] name="word"  /></label>
        {% if state.word %}
            <div><p>Reversed: <tt>{{ state.word|reversed }}</tt></div>
        {% else %}
            <p><em>Nothing entered!</em></p>
        {% endif %}
    </div>
</Template>
<State
    word=""
></State>
```
2. Try modifying the "word" state variable's initital value to see how that
changes the if statement.

3. Try writing your own if-statements based on other state variables of your
creations.


# Bonus - Script

While Modulo is designed to be useful even without JavaScript, sometimes you
just need access to that extra power of custom JavaScript code. Using
JavaScript, Modulo can be even used to develop more complicated interactive web
applications.

### The _Script_ CPart

To add JavaScript, use the _Script_ CPart. This CPart will execute the JS code
contained within once, immediately upon loading the component. See this
example:

```html
<Script>
    console.log("Hello JavaScript world!");
/Script>
```

In this above example, the _Script_ CPart will execute that JS code once, as
soon as it's loaded, causing the "console.log" to log that message to the web
browser's Developer Tools JavaScript console exactly once.

### Embedded components and script tags

Generally speaking, it's always desirable to put components in a separate file,
as was demonstrated in _Part 1_ with the `-src=` style attribute. This becomes
even more necessary if you want to use a _Script_ CPart. This is because of a
limitation with HTML: It does not support "nested" script tags. This means that
the `&lt;/Script>` tag will end up closing off the outer `script` tag early and
"interrupting" your component definition.

However, there is an alternative syntax to still allow a _Script_ CPart
embedded in your `&lt;script Modulo ...` definition, even without splitting it
off. This messier syntax is far from ideal, but can do in a pinch:

    &lt;def Script&gt;
        console.log("Hello JavaScript world!");
    &lt;/def&gt;

Note: Only use this alternative `def Script` syntax within a
`&gt;script Modulo ...` tag. There is no reason to use it when writing code in a
separate file!

> **Event directives** Let's break down that event directive:
> `@click:=script.sayHello`. First, note the at-sign: `@`. This is "syntactic
> sugar" for the `[component.event]` directive. This will attach a "click"
> event listener to the given element when that element is first mounted (i.e.
> displayed on the screen), and remove the listener if it leaves. In this case,
> we are using a `:=` style "data prop" style assignment, to assign the click
> event to point to the sayHello function of the _Script_ CPart. All functions
> defined in a _Script_ CPart will automatically be "exported" and available to
> click events, or in dataprops in general.

### Attaching click events

Typically, it's more useful to execute code when a user performs an action. To
do this, we must place the "console.log" into a function:

    <Script>
        function sayHello() {
            console.log("Hello JavaScript world!");
        }
    /Script>

Then, attach a "click" event directive to a HTML tag, such as, for example, a
button element:

    &lt;button @click:=script.sayHello&gt;Click me&lt;/button&gt;

Now, whenever a user clicks on the button, it will run the "sayHello" function,
logging the text into the JavaScript console.



##### Try it now

```modulo_demo
<Template>
    <button @click:="script.doLog">console.log a message</button>
</Template>
<Script>
    console.log("COMPONENT GOT LOADED!");
    function doLog() {
        console.log("Hello Modulo Scripting World!");
    }
/Script>
```

1.  Bring up the console: Press `Control+Shift+J` (Linux, Windows) or
`Command+Option+J` (macOS) on your keyboard to open the Console. Alternatively,
you can right-click with your mouse and select "Inspect", and then go to the
_Console_ tab.
2.  Do you see the "COMPONENT GOT LOADED!" text displayed in the console? It is
displayed once every time the component is loaded. By clicking "RUN", you can
"reload" the component, causing that message to show (or count up) again.
3.  Try now clicking on the button in the preview on the right. Do you see how
every time you click it shows (or counts) the text of the console.log in the
console?
4.  _Extra:_ Any number of functions can be defined in a _Script_ CPart.
Practice writing your own function that console logs a different message, and
then attaching it to a new button (or the existing button).
5.  _Extra:_ The "event" directive supports any event. Try changing "@click" to
"@mouseover", and then move your mouse over the button (without clicking). (For
the curious: [MDN has a list of all
events](https://developer.mozilla.org/en-US/docs/Web/Events#event_listing))

------

### Interacting with state

The _Script_ CPart is like the _Template_ CPart in one way: You get variables
referencing the other CParts. Within functions defined in the _Script_ CPart,
variables will be available representing the other CParts that have been
defined in the _Component_. As with the _Template_ CPart, the most useful
variables are `state`, with the current data in _State_ CPart (the "data"
Object), and `props`, with the value of the attributes that were passed to this
component.

Remember our "Holmes-style" detective work we did in the previous section? We
looked at a button which incremented a value when clicked. The JavaScript code
to increment a variable is `num++`, and for state data it can be:
`state.num++`.  Also, by default, components will rerender after every event
that you are listening to. With that in mind, examine the code of the Hello
button:


```modulo_demo
<Template>
    <button @click:="script.doCountup">Hello {{ state.num }}</button>
</Template>
<State
    count:=42
></State>
<Script>
    function doCountup() {
        state.num++;
    }
/Script>
```

By clicking on the button, it will increment the state value. Since the
component will rerender after the click, it will then change the DOM to show
the new number.

With the power of JavaScript, you can do all manner of things with the Script
tag. The [Examples page](/examples/) has all sorts of examples of more
complicated apps and applications. The typical use of a Script tag, thus, is to
create custom logic that manipulates or "puppets" the state, which in turn is
what controls the rendering of the component's HTML code by the Template CPart.

Keep in mind that the Script CPart is intended to be limited. Serious
JavaScript development should be split into separate JS files, or defined as
custom CParts. Thus, think of the Script CPart as more "filling in the gaps"
between CParts, which should do most of the heavy lifting (e.g. asynchronous
code, complicated API calls or data transformation, etc).

##### Key terms

* **Directive** \- A special type of HTML attribute that "hooks in"
  functionality to otherwise plain HTML elements. Three built-in directives
  include:
    * `:=` \- "data-prop" assignment, allowing for assigning to JavaScript
      values such as functions and/or primitive JavaScript data types in JSON
      syntax
    * `@click` \- attach event listener to element
* **Template tag** \- A more advanced type of Template code that lets us repeat
  or optionally include other templat code based on data contained in state,
  props, or from a static data CPart
* **Script** \- CPart that enables embedding of arbitrary JavaScript code, and
  allowing for easy access to CPart interface, and exposing JS functions to be
  attached as events

-----

#### Next step

That's all for the Modulo tutorial! Modulo is still in early development, so
it's likely the tutorial will expand in the future to cover more aspects of
Modulo development.
