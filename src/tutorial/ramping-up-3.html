<!DOCTYPE HTML><script Modulo src="/static/js/Modulo.js" -src="/static/components/cms/"></script><cms-MarkdownPage><script type=md>---
tutorial: Part 3
---


In Part 3 of this tutorial, we'll start exploring code that permits individual
components to store, modify, and link together data, allowing for complex
behaviors. 

This is a challenging section! If you are new to JavaScript, try to understand
as much as you can of this part of the tutorial, but don't feel bad if some
parts seem extra hard.

We'll learn how to use Template Tags, to optionally include, or duplicate parts
of our HTML templates for data or properties.  We'll learn how to use
StaticData, that lets us import JSON or CSV file types, or APIs that use these
types, into our Modulo components, so that we can use template tags to explore
3rd party data.

Before we get to these more powerful features of Modulo, we'll need to first
explore Data Props, and how they enable different JavaScript data types.

# Data Props

> **Other Directives** - All directives are "provided" by a CPart. That is,
> including CParts in your component definition may "enable" more directives in
> your HTML. Data-prop (`[component.dataProp]` or `:=`), for example, is a
> built-in feature of the _Component_, which means it's always available.
> Directives are not the main focus of this tutorial.  To learn more, including
> how to author your own directives using JavaScript, [see
> _Directives_](/docs/directives.html). However, for the purpose of this
> tutorial we will have no need to use directives outside of the built-in
> directives that come with Modulo.

Before we go any deeper into Template Tags or _StaticData_, we need to explore
"data props", and before that, we need to review _directives_. The term
_directives_ in Modulo refers to special attributes that you add to HTML to add
extra functionality.. You can recognize a _directive_ by spotting certain
special characters in the attribute name. We've seen one in the previous
tutorial section, `[state.bind]`. For example, `<input [state.bind] />` is an
`input` HTML tag with a `[state.bind]` directive. Some directives will have a
square-bracket syntax (e.g. `[ ]`), while others might use other special
characters to set them apart from "normal" attributes (e.g.  `:=` syntax we'll
learn next). While re-rendering, Modulo scans the resulting DOM to set-up or
"mount" any directives it encounters.

Directives are useful for a variety of tasks, ranging connecting CParts to each
other, to more complicated modifications to DOM elements.  ).

## The dataProp directive `:=`

We'll learn one more directive next: _data prop_  or `:=` syntax

> **Why don't we use "strings" for numbers?** Using strings of digits (i.e. in
> quotes) instead of the numbers themselves means that things like arithmetic
> won't work as intended. Example: If state variable `count="1"`, then
> `state.count + 10` will result in `"110"` instead of the desired `11`, since
> it's a string of digits, so `"1" + "10" = "110"`

Typically, when we add attributes to anything, whether it is a CPart or even
just in regular HTML, the attribute value can only be a string. This means when
we did `<State count="1" ... >` previously, we made a mistake: The `count`
variable didn't get assigned to `1` the _Number_, but rather `"1"` the
_String_. To fix it, we do the following:

    <State
        count:=1
        color="blue"
    >&lt;/State&gt;

This is called a _data prop_ directive. You can identify a _data prop_
directive (`:=`), by spotting an attribute name that is suffixed with a colon
right before the equal sign, like this: `attributeName:=value`.

## The many types of data you'll see

Modulo uses the same data types as JavaScript and the JSON file format, which
Modulo uses extensively. The remainder of this section will highlight the most
useful types for new Modulo developers:

### Strings & Numbers

String is the default. If you don't use `:=` it will be a plain old string. That refers
to a "string of characters", and is used for generic text.

If you use the `:=` syntax followed by a number, like `:=10` or `:=32.4`, you
create a value of the Number type.  This is useful for numeric data that you want to do
calculations on.

Examples of both are below:

```
<State
    stringval="Hello world!"
    another="
        Strings can be more
        than one line.
    "
    count:=1
    debt:=-2
    x:=912.3
    y:=123.234
></State>
```

### Array

> **Iterables** - There are some types of data that are called "iterable". That
> means you can "iterate" over them, or repeat code for them. A good rule of
> thumb is if the data in question is "plural". Plural data is iterable. For
> example, if you want to show a single profile picture, that's not plural. If
> you want to show every profile picture (whether that is 0 or 100), that
> matches a search result, that is "plural", and that is when we want to use an
> iterable.

Arrays are the most important type of "container type" in JavaScript, that is,
a type that can contain other types. Next in the tutorial we'll cover how to
use Arrays to duplicate template code across data, but for now let's start with
the syntax. In this case, we'll make an *Array of Numbers* and an *Array of
Strings*, called `dataset` and `cities` respectively:

```
<State
    dataset:='[ 103, 32, 15, 100 ]'
    cities:='[ "Berkeley", "Porto Alegre" ]'
></State>
```

### Arrays of Objects

When we access real-world data, whether those are blog articles in a publishing
site, or a data items in a dashboard, they often "arrive formatted" as what's
called a JSON array of objects.

This is a much more complicated data format. We'll encounter it again in a
moment, when we start using StaticData. For now, scan the following format
containing some imaginary "traffic rating" about two train stations:

```
<State
    stations:='[
        {
            "name": "Embarcadero Station - San Francisco",
            "trafficRating": 1353
        },
        {
            "name": "19th Street Station - Oakland",
            "trafficRating": 732
        }
    ]'
></State>
```



### Final notes on Data Props

-  Keep in mind that _data props_ directives are not the same as the _Props_
   CPart. They are, however, related, in that the _Props_ CPart looks for both
   regular attributes and data props: You can in fact set any _Props_
   attributes with the `:=` syntax, for data other than Strings.
-  There are a few more types as well: `null`, `true`, `false`, which are
   simple types used to "flag" items, or set a property "on and off", or for
   placeholder values
-  _Data props_ support any JSON literal type. Technically, _data props_ values
   can have double quotes just like normal String-based attributes.  However,
   as a stylistic convention, you may omit the double quotes for any one-word
   value, and should use only single quotes for complex types, such as
   JSON-formatted Arrays or Objects. See below for stylistic examples of data
   props with different types:


##### Try It Now

1. Examine the code below, and it's output.

```modulo_demo
<Template>
    Adding strings: {{ state.a|add:state.b }}<br />
    Adding numbers: {{ state.d|add:state.e }}
</Template>
<State
    a="10"
    b="20"
    d:=10
    e:=20
></State>
```

2. Numbers can actually "do math", as opposed to strings that you'd only
combine end-to-end, but not "do math". For example, `5 + 5 = 10` in Number
arithmetic, while `"5" + "5" = "55"` in string arithmetic. Knowing that, do you
see how the code above shows the important difference between Numbers and
Strings?

3. Let's see how we can use filters to "poke" at an Array. Examine the next bit
of code. Do you see how you can access individual items in an Array using the
`|get` filter?

```modulo_demo
<Template>
    {{ state.items|get:3 }}
    <p>Items separated by a dash: {{ state.items|join:"-" }}</p>
    <p>Items in JSON format: {{ state.items|json }}</p>
</Template>
<State
    items:='[ "toothbrush", "umbrella", "my bag", "laptop", "charger" ]'
></State>
```

##### Exploration Questions

* **Why do you think `|get:3` produces "laptop"?** Answer: Modulo  starts
  counting the "index" of Arrays at "index number 0". This is the same behavior
  as JavaScript.

* **What is the purpose of JSON format?** JSON is a standard file format that
  Modulo can read in. Any (strictly) JSON formatted data structure can be
  inserted in a Modulo dataProp, e.g. `dataprop:='{"Hello": "World"}'`

-----------



# Template Tags

> **Built-in Template Tags and Custom Template Tags** - Modulo comes with many
> template-tags pre-installed: Read [Templating Reference - Built-In
> Tags](/docs/templating/tags.html#builtintags) for examples of all
> template-tags available.  This includes the "if" template-tag, which allows
> for conditional rendering (e.g.  "only show the submit button if a form is
> filled correctly"), and the "for" template-tag, which allows for HTML to be
> repeated for each item of some given data (e.g. "every blog post get's it's
> own `<li>` element").  Utilizing JavaScript, you can also define custom tags,
> although it is more challenging than with filters.


## Intro to Template Tags

In addition to filters, the Modulo templating language also support powerful
"template tags", which allow for more complicated custom behavior.  Unlike
template variables or filters, they use `{%` and `%}` (instead of `{{` and
`}}`) to designate where they are in the _Template_ code.

### Syntax

Template tags are in the format of `{% tag %}`. 
They allow for more complicated transformations to the HTML code generated.
For example, here are a few:

    {% include other_template %}

    {% comment %}
        ...
    {% endcomment %}

    {% if state.expanded %}
        ...
    {% endif %}


## The if-tag

One of the most useful template tags you will use is the if tag, written like
this: `{% if %}`.  The if-tag allows for conditional rendering of HTML code
based on the condition supplied.

See below for two examples of using the "if" tag:

    <h1>{{ props.title }}</h1>
    {% if state.expanded %}
        <div><p>Details: {{ props.details }}</p></div>
    {% endif %}
    <hr />
    {% if props.link %}
        <a href="{{ props.link }}">Read more...</a>
    {% else %}
        <em>(No link provided)</em>
    {% endif %}


Note that there are two other tags in the mix. These a related to the `if` tag,
and will only show up after the `if` tag. The first is the `{% endif %}` tag.
This is required, since it shows Modulo what you want the `if` tag to
conditionally include. The second is the `{% else %}` tag. This is optional.
You do not need to include this for all examples.



## The for-tag

The "for-tag" is for when we want to duplicate a bit of template over and over
for a repetitive bit fo data. For example, if we want to template "for every
article", or "for every pin in a world map", or "for every post in an article
comment section". Each of these "for" statements refers to some plural thing
that we want to have a similar style duplicated across, using the same HTML
template for each item in that collection.

For example, imagine showing a paragraph for every student in a class's roster:

    {% for name in state.names %}
        <p>Name on roster: {{ name }}</p>
    {% endif %}


Or, refer to the `stations:=` _State_ data example above, a for loop can also
loop through other types of data, formatting it in a reasonable way:


    {% for station in state.stations %}
        <p>{{ station.name }} | TRAFFIC SCORE: {{ station.trafficRating }}</p>
    {% endif %}


In this example, the `{{ station.name }}` and `{{ station.trafficRating }}`
refer to templating the individual values within the station object in the
array of stations.

Like the "if", for has an "endfor", which it uses to designate the portion of
the temlpate it will repeat. Unlike "if", it can use the template it 0 times, 1
time, or 2+ times (`if-tags` can use the template only 0 times or 1 time, but
can never "duplicate" the template and use it 2+ times).


##### Try It Now

1. Examine the code below. Do you understand how the `if` template-tag checks
the value of `state.word`  to see if it is filled in, and only shows it back to
the user when the user has started typing?

```modulo_demo
<Template>
    <div>
        <label>Enter a word to see it reversed:
            <input [state.bind] name="word"  /></label>
        {% if state.word %}
            <div><p>Reversed: <tt>{{ state.word|reversed }}</tt></div>
        {% else %}
            <p><em>Nothing entered!</em></p>
        {% endif %}
    </div>
</Template>
<State
    word=""
></State>
```
2. Try modifying the "word" state variable's initital value to see how that
changes the if statement.

3. Try writing your own if-statements based on other state variables of your
creations.


##### Try It Now

1. Examine the code below. Do you see how the `for` template-tag "duplicates"
the inner template for every item in the array of items?


```modulo_demo
<Template>
    <ol>
    {% for item in state.items %}
        <li>{{ item }}</li>
    {% endfor %}
    </ol>
</Template>
<State
    items:='[ "toothbrush", "umbrella", "my bag", "laptop", "charger" ]'
></State>
```


2. Try adding `|reversed` filter to the `items`, so it becomes `{% for item in
items|reversed %}`. What do you think this will do?



-----------


# StaticData

_StaticData_ is a CPart used to import data from a JSON or CSV source, such as
a file or API. Unlike _State_, it is for "static" or unchanging data. When
building or deploying, it will be bundled together for speedy look-ups.

What are JSON files? Here's an example:

<https://www.gov.uk/bank-holidays.json>


```js
{"england-and-wales":{"division":"england-and-wales","events":[{"title":"New Year’s Day","date":"2018-01-01",....
```
Okay, that's hard to read! But if you look closely through it, you recognize
that it contains information about holidays in the UK, as provided by the
government of the UK. That could be useful in a calendar app, or many other
situations. In Modulo, it would be read like this:

    <StaticData
        -src="https://www.gov.uk/bank-holidays.json"
    ></StaticData>


Combining that with the `|json:2` filter, we can display a formatted version of
it this way:

```modulo_demo
<Template>
    <pre>{{ staticdata|json:2 }}</pre>
</Template>
<StaticData
    -src="https://www.gov.uk/bank-holidays.json"
></StaticData>
<Style>
    pre {
        height: 150px;
        overflow: auto;
    }
</Style>
```

Okay, that's still hard to see, but it looks like "england-and-wales" is a
_key_, as well as _events_ is a key. This means we can use `|get` to access
just the events, which is what we care about:


```modulo_demo
<Template>
    <pre>{{ staticdata|get:"england-and-wales.events"|json:2 }}</pre>
</Template>
<StaticData
    -src="https://www.gov.uk/bank-holidays.json"
></StaticData>
<Style>
    pre {
        height: 100px;
        overflow: auto;
    }
</Style>
```

With this information, we can combine it with the `for` template tag, to
display all the holidays in a table in the next TRY IT NOW.

##### Try It Now

```modulo_demo
<Template>
    <h3>Title</h3><h3>Date</h3>
    {% for event in staticdata|get:"england-and-wales.events" %}
        <div>{{ event.title }}</div>
        <div>{{ event.date }}</div>
    {% endfor %}
</Template>
<StaticData
    -src="https://www.gov.uk/bank-holidays.json"
></StaticData>
<Style>
    :host {
        height: 200px;
        overflow: auto;
        display: grid;
        grid-template-columns: 1fr 1fr;
    }
    div {
        font-size: 0.8rem;
    }
</Style>
```



1. Examine the code above. Do you understand how the `get` filter accesses the
data we need, and then the `for` template-tag loops through that data showing
it in a grid format (thanks to CSS `display: grid`)?

2. Bonus challenge: Try visualizing other data sets you find.  Can you display
a table or details of some data set or JSON-based API you find online? For
example, try using GitHub's API:
<https://docs.github.com/en/rest/guides/getting-started-with-the-rest-api>


-----------



# Bonus - Script

Just to round out this tutorial, let's peak at the last, most important
Component Part: Script. If you are a total newbie when it comes to JavaScript,
this section might make less sense - feel free to skip over.

While Modulo is designed to be useful even without JavaScript, sometimes you
just need access to that extra power of custom JavaScript code. Using
JavaScript, Modulo can be even used to develop more complicated interactive web
applications.

### The _Script_ CPart

To add JavaScript, use the _Script_ CPart. This CPart will execute the JS code
contained within once, immediately upon loading the component. See this
example:

```html
<Script>
    console.log("Hello JavaScript world!");
/Script>
```

In this above example, the _Script_ CPart will execute that JS code once, as
soon as it's loaded, causing the "console.log" to log that message to the web
browser's Developer Tools JavaScript console exactly once.

### Embedded components and script tags

Generally speaking, it's always desirable to put components in a separate file,
as was demonstrated in _Part 1_ with the `-src=` style attribute. This becomes
even more necessary if you want to use a _Script_ CPart. This is because of a
limitation with HTML: It does not support "nested" script tags. This means that
the `&lt;/Script>` tag will end up closing off the outer `script` tag early and
"interrupting" your component definition.

However, there is an alternative syntax to still allow a _Script_ CPart
embedded in your `&lt;script Modulo ...` definition, even without splitting it
off. This messier syntax is far from ideal, but can do in a pinch:

    &lt;def Script&gt;
        console.log("Hello JavaScript world!");
    &lt;/def&gt;

Note: Only use this alternative `def Script` syntax within a
`&gt;script Modulo ...` tag. There is no reason to use it when writing code in a
separate file!

> **Event directives** Let's break down that event directive:
> `@click:=script.sayHello`. First, note the at-sign: `@`. This is "syntactic
> sugar" for the `[component.event]` directive. This will attach a "click"
> event listener to the given element when that element is first mounted (i.e.
> displayed on the screen), and remove the listener if it leaves. In this case,
> we are using a `:=` style "data prop" style assignment, to assign the click
> event to point to the sayHello function of the _Script_ CPart. All functions
> defined in a _Script_ CPart will automatically be "exported" and available to
> click events, or in dataprops in general.

### Attaching click events

Typically, it's more useful to execute code when a user performs an action. To
do this, we must place the "console.log" into a function:

    <Script>
        function sayHello() {
            console.log("Hello JavaScript world!");
        }
    /Script>

Then, attach a "click" event directive to a HTML tag, such as, for example, a
button element:

    &lt;button @click:=script.sayHello&gt;Click me&lt;/button&gt;

Now, whenever a user clicks on the button, it will run the "sayHello" function,
logging the text into the JavaScript console.



##### Try it now

```modulo_demo
<Template>
    <button @click:="script.doLog">console.log a message</button>
</Template>
<Script>
    console.log("COMPONENT GOT LOADED!");
    function doLog() {
        console.log("Hello Modulo Scripting World!");
    }
/Script>
```

1.  Bring up the console: Press `Control+Shift+J` (Linux, Windows) or
`Command+Option+J` (macOS) on your keyboard to open the Console. Alternatively,
you can right-click with your mouse and select "Inspect", and then go to the
_Console_ tab.
2.  Do you see the "COMPONENT GOT LOADED!" text displayed in the console? It is
displayed once every time the component is loaded. By clicking "RUN", you can
"reload" the component, causing that message to show (or count up) again.
3.  Try now clicking on the button in the preview on the right. Do you see how
every time you click it shows (or counts) the text of the console.log in the
console?
4.  _Extra:_ Any number of functions can be defined in a _Script_ CPart.
Practice writing your own function that console logs a different message, and
then attaching it to a new button (or the existing button).
5.  _Extra:_ The "event" directive supports any event. Try changing "@click" to
"@mouseover", and then move your mouse over the button (without clicking). (For
the curious: [MDN has a list of all
events](https://developer.mozilla.org/en-US/docs/Web/Events#event_listing))

------

### Interacting with state

The _Script_ CPart is like the _Template_ CPart in one way: You get variables
referencing the other CParts. Within functions defined in the _Script_ CPart,
variables will be available representing the other CParts that have been
defined in the _Component_. As with the _Template_ CPart, the most useful
variables are `state`, with the current data in _State_ CPart (the "data"
Object), and `props`, with the value of the attributes that were passed to this
component.

Remember our "Holmes-style" detective work we did in the previous section? We
looked at a button which incremented a value when clicked. The JavaScript code
to increment a variable is `num++`, and for state data it can be:
`state.num++`.  Also, by default, components will rerender after every event
that you are listening to. With that in mind, examine the code of the Hello
button:


```modulo_demo
<Template>
    <button @click:="script.doCountup">Hello {{ state.num }}</button>
</Template>
<State
    num:=42
></State>
<Script>
    function doCountup() {
        state.num++;
    }
/Script>
```

By clicking on the button, it will increment the state value. Since the
component will rerender after the click, it will then change the DOM to show
the new number.

With the power of JavaScript, you can do all manner of things with the Script
tag. The [Examples page](/examples/) has all sorts of examples of more
complicated apps and applications. The typical use of a Script tag, thus, is to
create custom logic that manipulates or "puppets" the state, which in turn is
what controls the rendering of the component's HTML code by the Template CPart.

Keep in mind that the Script CPart is intended to be limited. Serious
JavaScript development should be split into separate JS files, or defined as
custom CParts. Thus, think of the Script CPart as more "filling in the gaps"
between CParts, which should do most of the heavy lifting (e.g. asynchronous
code, complicated API calls or data transformation, etc).

##### Key terms

* **Directive** \- A special type of HTML attribute that "hooks in"
  functionality to otherwise plain HTML elements. Three built-in directives
  include:
    * `:=` \- "data-prop" assignment, allowing for assigning to JavaScript
      values such as functions and/or primitive JavaScript data types in JSON
      syntax
    * `@click` \- attach event listener to element
* **Template tag** \- A more advanced type of Template code that lets us repeat
  or optionally include other templat code based on data contained in state,
  props, or from a static data CPart
* **Script** \- CPart that enables embedding of arbitrary JavaScript code, and
  allowing for easy access to CPart interface, and exposing JS functions to be
  attached as events

-----

#### Next step

That's all for the Modulo tutorial! Modulo is still in early development, so
it's likely the tutorial will expand in the future to cover more aspects of
Modulo development.
